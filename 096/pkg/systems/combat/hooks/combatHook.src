/* $Id$
 *
 * NOTES:
 *	Return 0 if you want the core to handle the
 *	combat cycle. Return 1 to say that the cycle is over.
 */

use uo;
use os;
use polsys;
use cfgfile;

include ":attributes:attributes";
include ":brainai:npcUtil";
include ":combat:armorZones";
include ":combat:settings";
include ":damage:damage";
include ":itemutils:itemdesc";
include "include/client";
include "include/facings";

/*
 * Global variables
 * With the way hooks work, these are only set only ONCE
 * and stay the same in every instance the hook gets run.
 */
var g_item_cfg := ReadConfigFile(":*:itemdesc");
var g_settings_cfg := CS_GetSettingsCfgFile();

program Install()
	print("INSTALLING: Combat hook... ");
	return 1;
endprogram

exported function Attack(attacker, defender)
	if ( !g_settings_cfg["Settings"].EnableHook )
		return 0;
	elseif ( !CanAttack(attacker, defender) )
		return 1;
	endif

	var a_info, d_info;
	SetupInfo(attacker, defender, a_info, d_info);

	if ( !DistanceChecks(a_info, d_info) )
		return 1;
	elseif ( !AmmoChecks(a_info, d_info) )
		return 1;
	else
		if ( g_settings_cfg["General"].ForceFacing )
			TurnObjectToward(attacker, defender.x, defender.y);
			TurnObjectToward(defender, attacker.x, attacker.y);
		endif

		PlayAttackAnimation(a_info);
	endif

	var difficulty := CalcHitDifficulty(a_info, d_info);
	if ( SkillCheck(attacker, GetConfigString(a_info.cfginfo, a_info.prefix+"Attribute"), difficulty) > 0 )
		PlayHitSound(a_info, d_info);

		Print("*-------------------*");
		var base_damage := CalcBaseDamage(a_info);
		Print("BaseDmg="+base_damage);
		var raw_damage := base_damage;
		ParryChecks(attacker, defender, raw_damage);
				
		var armor_hit := GetArmorHit(d_info);
		ArmorChecks(d_info, armor_hit, raw_damage);
		
		Print("RawDamage="+base_damage);
		ApplyRawDamageEX(d_info.mobile, raw_damage);
		Print("@-------------------@");
	else
		PlayMissSound(a_info);
	endif
	
	return 1;
endfunction

function CanAttack(attacker, defender)
	if ( attacker == defender )
		return 0;
	elseif ( !CheckLineOfSight(attacker, defender) )
		return 0;
	endif

	return 1;
endfunction

function DistanceChecks(byref a_info, byref d_info)
	var cur_range := Distance(a_info.mobile, d_info.mobile);
	var max_range := GetConfigInt(a_info.cfginfo, a_info.prefix+"MaxRange");
	if ( max_range == error )
		max_range := 1;
	endif
	
	if ( cur_range > max_range )
		CombatMsg(a_info.mobile, "Opponent is too far away. ["+max_range+"]", "Dist");
		return 0;
	elseif ( cur_range < CInt(GetConfigInt(a_info.cfginfo, a_info.prefix+"MinRange")) )
		CombatMsg(a_info.mobile, "Opponent is too close.", "Dist");
		return 0;
	else
		return 1;
	endif
endfunction

function AmmoChecks(byref a_info, byref d_info)
	if ( !(a_info.cfginfo).AmmoType )
		return 1;
	endif

	if ( ConsumeSubstance((a_info.mobile).backpack, (a_info.cfginfo).AmmoType, 1) )
		PlayMovingEffect(a_info.mobile, d_info.mobile, (a_info.cfginfo).ProjectileAnim, 10, 10);
		return 1;
	else
		CombatMsg(a_info.mobile, "You do not have any "+GetObjTypeDesc((a_info.cfginfo).AmmoType, 1)+"!", "Ammo");
		return 0;
	endif
endfunction

function PlayAttackAnimation(byref a_info)
	var attack_anim := ANIM_FIDGET_1; // Default attack anim for NPCs.
	if ( (a_info.cfginfo).Anim )
		// Normal weapons
		var anim_list := GetConfigStringArray(a_info.cfginfo, "Anim");
		attack_anim := anim_list[RandomInt(anim_list.Size())+1];
	elseif ( (a_info.cfginfo).AttackAnimation )
		// NPC intrinsic weapons
		var anim_list := GetConfigStringArray(a_info.cfginfo, "AttackAnimation");
		attack_anim := anim_list[RandomInt(anim_list.Size())+1];
	endif

	PerformAction(a_info.mobile, CInt(attack_anim));

	return attack_anim;
endfunction

function CalcHitDifficulty(byref a_info, byref d_info)
	return RandomInt(100);
	//hit_chance = (weapon_attribute + 50.0) / (2.0 * opponent_weapon_attribute + 50.0)
	var a_skill := AP_GetSkill(a_info.mobile, GetConfigString(a_info.cfginfo, a_info.prefix+"Attribute"));
	var d_skill := AP_GetSkill(d_info.mobile, GetConfigString(d_info.cfginfo, d_info.prefix+"Attribute"));
	
	return ((a_skill + 50.0) / (2.0 * d_skill + 50)) * 100;
endfunction

function PlayHitSound(byref a_info, byref d_info)
	var hit_sound := GetConfigStringArray(a_info.cfginfo, a_info.prefix+"HitSound");
	hit_sound := hit_sound[RandomInt(hit_sound.Size())+1];
	PlaySoundEffect(a_info.mobile, CInt(hit_sound));

	var damaged_sound;
	if ( (d_info.mobile).npctemplate )
		damaged_sound := GetConfigStringArray(d_info.cfginfo, "DamagedSound");
	else
		case ( (d_info.mobile).gender )
			0:// Male
				damaged_sound := array{341, 342, 343, 345, 346};
				break;
			1://Female
				damaged_sound := array{332, 333, 334, 335, 336};
				break;
		endcase
	endif
	damaged_sound := damaged_sound[RandomInt(damaged_sound.Size())+1];

	PlaySoundEffect(d_info.mobile, CInt(damaged_sound));

	return 1;
endfunction

function PlayMissSound(byref a_info)
	var miss_sound := GetConfigStringArray(a_info.cfginfo, a_info.prefix+"MissSound");
	miss_sound := miss_sound[RandomInt(miss_sound.Size())+1];
	PlaySoundEffect(a_info.mobile, CInt(miss_sound));

	return 1;
endfunction

function CalcBaseDamage(byref a_info)
	var base_dmg := GetConfigString(a_info.cfginfo, a_info.prefix+"Damage");
	Print("CalcBaseDamage(1) Dice = ["+a_info.prefix+"Damage"+"] "+base_dmg);
	base_dmg := RandomDiceRoll(base_dmg);
	Print("CalcBaseDamage(1) BaseDamage = "+base_dmg);

	var dmg_mult := CDbl(AP_GetSkill(a_info.mobile, TACTICS))+50.0;
	dmg_mult := dmg_mult + (CDbl(AP_GetStat(a_info.mobile, STRENGTH)) * 0.2);
	dmg_mult := CDbl(dmg_mult) * 0.01;
	base_dmg := base_dmg * dmg_mult;
	Print("CalcBaseDamage(2) BaseDamage = "+base_dmg);

	return CInt(base_dmg);
endfunction

function ParryChecks(byref a_info, byref d_info, byref raw_damage)
	var shield := d_info.shield;
	if ( !shield )
		return 0;
	endif

	var parry_elem := g_settings_cfg["Parry"];
	var divisor := CDbl(parry_elem.ParryDivisor);
	var roll := CDbl(parry_elem.ParryRoll);
	var parry_chance := CDbl(AP_GetSkill(a_info.mobile, PARRY)) / divisor;

	if ( RandomFloat(roll) < parry_chance )
		PerformAction(d_info.mobile, ANIM_TWIST_DODGE);
		SendSysMessage(d_info.mobile, "You deflect some damage using your shield.");
		raw_damage := raw_damage - RandomInt(shield.ar)+1;
		Print("ParryChecks() RawDamage -"+raw_damage);

		if ( raw_damage > CInt(0.15*shield.hp) )
			SendSysMessage(d_info.mobile, shield.desc+" takes some damage.");
			shield.quality := shield.quality * CDbl(parry_elem.WearRate);
			if ( shield.quality <= 0.1 )
				SendSysMessage(d_info.mobile, shield.desc+" has been destroyed.");
				DestroyItem(shield);
			elseif ( shield.hp > shield.maxhp )
				shield.hp := shield.maxhp;
			endif
		endif
	endif

	return 1;
endfunction

function GetArmorHit(byref d_info)
	var hit_zone := CS_GetRandomArmorZone();
	var armor_hit := CS_GetEquipmentInArmorZone(d_info.mobile, hit_zone);
	
	if ( armor_hit.Size() < 1 )
		return 0;
	endif
	
	var best_armor := 0;
	foreach item in ( armor_hit )
		if ( item.ar > best_armor.ar )
			best_armor := item;
		endif
		SleepMS(2);
	endforeach
	
	return best_armor;
endfunction

function ArmorChecks(byref d_info, armor_hit, byref raw_damage)
	Print("ArmorChecks(1) RawDamage = "+raw_damage);
	var blocked := CInt(armor_hit.ar) + (d_info.mobile).ar_mod;
	Print("ArmorChecks(1) Blocked -"+blocked);
	var absorbed := blocked / 2;
	Print("ArmorChecks(1) Absorbed = "+absorbed);
	blocked := blocked - absorbed;
	Print("ArmorChecks(2) Blocked = "+blocked);
	absorbed := absorbed + RandomInt(blocked+1)+1;
	Print("ArmorChecks(2) Absorbed = "+absorbed);
	raw_damage := raw_damage - absorbed;
	Print("ArmorChecks(2) RawDamage = "+raw_damage);
	
	if ( raw_damage >= 2.0 )
		raw_damage := raw_damage * 0.5;
	endif
	Print("ArmorChecks(3) RawDamage = "+raw_damage);
	
	if ( !armor_hit.IsA(POLCLASS_ARMOR) )
		return 1;
	endif
	
	var armor_elem := g_settings_cfg["Armor"];
	if ( RandomInt(100)+1 < armor_elem.WearChance )
		SendSysMessage(d_info.mobile, armor_hit.desc+" takes some damage.");
		armor_hit.hp := armor_hit.hp - 1;
		
		if ( armor_hit.hp <= 1 )
			SendSysMessage(d_info.mobile, armor_hit.desc+" has been destroyed.");
			DestroyItem(armor_hit);
		endif
	endif
		
	return 1;
endfunction

function SetupInfo(attacker, defender, byref a_info, byref d_info)
	a_info := struct;
	a_info.+mobile := attacker;
	if ( attacker.IsA(POLCLASS_NPC) && (attacker.weapon).intrinsic )
		a_info.+prefix := "Attack";
		a_info.+cfginfo := NPC_GetNPCConfig(attacker.npctemplate);
	else
		a_info.+prefix := "";
		a_info.+cfginfo := g_item_cfg[(attacker.weapon).objtype];
	endif

	d_info := struct;
	d_info.+mobile := defender;
	if ( defender.IsA(POLCLASS_NPC) && (defender.weapon).intrinsic )
		d_info.+prefix := "Attack";
		d_info.+cfginfo := NPC_GetNPCConfig(defender.npctemplate);
	else
		d_info.+prefix := "";
		d_info.+cfginfo := g_item_cfg[(defender.weapon).objtype];
	endif
	var shield := GetEquipmentByLayer(defender, LAYER_HAND2);
	if ( shield.ISA(POLCLASS_ARMOR) )
		d_info.+shield := shield;
	endif

	return 1;
endfunction

function CombatMsg(mobile, text, type:="")
	// This is done just to prevent message spam on fast weapons.
	if ( CInt(GetObjProperty(mobile, "#CH-Msg"+type)) < ReadMillisecondClock() )
		SendSysMessage(mobile, text);
		SetObjProperty(mobile, "#CH-Msg"+type, ReadMillisecondClock()+800);
	endif

	return 1;
endfunction

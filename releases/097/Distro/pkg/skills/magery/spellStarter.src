/*
 * $Id$
 *
 */

use uo;
use os;
use cfgfile;

include ":attributes:attributes";
include ":magery:spells";

include ":containers:containers";
include ":itemutils:itemdesc";
include "include/client";
include "include/sounds";

program SpellStarter(params)
	var mobile := params[1]; // Caster
	var spell_id := params[2]; // Id # of the spell
	var scroll := params[3]; // Scroll object being used
	var targ := params[4]; // NPC target

	if ( !Attach(mobile) )
		SendSysMessage(mobile, "You are already doing something.");
		return 0;
	endif

	var spell_elem := MS_GetSpellsCfgElem(spell_id);

	// If spell is set to 'TestOnly 1', then it requires cmdlevel or #SpellTester CProp before it can be used.
	if ( spell_elem.TestOnly and !mobile.cmdlevel )
		// TestOnly spell, check for #SpellTester
		if ( !GetObjProperty(mobile, "#SpellTester") )
			SendSysMessage(mobile, "This spell has been temporarily disabled.");
			FailSpell(mobile);
			return 0;
		endif
	elseif ( spell_elem.NPCOnly && !mobile.npctemplate )
		PrintTextAbove(mobile, "Unable to cast - NPC only spell.");
		return 0;
	endif

	// Perform various checks to see if mobile can perform the spell
	var requires_mana := 1;
	var requires_regs := 1;
	var settings_elem := MS_GetSettingsCfgElem("Settings");

	if ( !mobile.IsA(POLCLASS_NPC) && (mobile.cmdlevel >= settings_elem.StaffCmdLvl) )
		requires_mana := CInt(settings_elem.StaffRequiresMana);
		requires_regs := CInt(settings_elem.StaffRequiresReagents);
	endif

	if ( GetObjProperty(mobile, "#Casting") )
		SendSysMessage(mobile, "You can not cast right now.");
		return 0;
	elseif ( mobile.squelched && !mobile.npctemplate )
		SendSysMessage(mobile, "Something prevents you from casting.");
		FailSpell(mobile);
		return 0;
	elseif ( !EquipmentCheck(mobile) )
		SendSysMessage(mobile, "Your hands must be free to cast spells or meditate.");
		FailSpell(mobile);
		return 0;
	elseif ( mobile.frozen )
		SendSysMessage(mobile, "You cannot cast a spell while frozen.");
		FailSpell(mobile);
		return 0;
	endif

	if ( requires_mana )
		if ( !AP_ConsumeVital(mobile, MANA, spell_elem.ManaCost) )
			SendSysMessage(mobile, "You don't have enough mana to cast that spell!");
			FailSpell(mobile);
			return 0;
		endif
	endif

	if ( requires_regs )
		if ( !CheckReagents(mobile, spell_elem, scroll) )
			SendSysMessage(mobile, "You don't have the proper reagents.");
			FailSpell(mobile);
			return 0;
		endif
	endif

	// Perform casting animation
	case ( Lower(spell_elem.Target) )
		"none":
		"direct":
			PerformAction(mobile, ANIM_CAST_DIR);
			break;
		"area":
		"summon":
			PerformAction(mobile, ANIM_CAST_AREA);
			break;
		default:
			PerformAction(mobile, ANIM_CAST_DIR);
	endcase

	// Just in case you want to send events to this script
	SetObjProperty(mobile, "#Casting", GetPid());
	mobile.frozen := 1;
	mobile.hidden := 0;
	EraseObjProperty(mobile, "#Medding");
	SpeakPowerWords(mobile, spell_id);

	var orig_hp := AP_GetVital(mobile, "Hits");
	var delay := spell_elem.Delay;
	var protection := GetObjProperty(mobile, "Protection");

	while ( delay > 0 )
		if ( !protection )
			// There is a small chance, perhaps, that the mobile is damaged and then regens
			// or is healed enough in the ~50ms delay between checking. It could be more
			// accurate to grab the pid from ApplyDamageEX and send a damaged event to this
			// script, on top of also checking the health.
			if ( orig_hp > AP_GetVital(mobile, "Hits") )
				SendSysMessage(mobile, "Your concentration is disturbed, thus ruining thy spell.");
				FailSpell(mobile);
				PlaySoundEffect(mobile, SFX_SPELL_FAIL);
				PlayObjectCenteredEffect(mobile, GFX_FIZZLE, 5, 50);
				return 0;
			endif
		endif

		if ( !(delay % 50) )
			delay -= 50;
			SleepMS(50);
		else
			delay -= (delay % 50);
			SleepMS(delay % 50);
		endif

	endwhile

	var attribute := spell_elem.Attribute;

	if ( !attribute )
		attribute := MAGERY;
	endif

	var difficulty := spell_elem.Difficulty;

	if ( difficulty == error )
		difficulty := -1;
	endif

	var skill_check := SkillCheck(mobile, attribute, difficulty);
	mobile.frozen := 0;

	// skill_check > 0 on success
	if ( skill_check > 0 )
		var info := struct;
		info.+script := spell_elem.Script;
		info.+attribute := attribute;
		info.+skill_check := skill_check;
		info.+targ := targ;
		info.+pid := GetPid();
		info.+spell_id := spell_id;

		// Include base damage in info if there is a DamageType
		if ( spell_elem.DamageType != error )
			info.+damage_type := spell_elem.DamageType;
			info.+min_damage := GetConfigReal(spell_elem, "MinBaseDamage");
			info.+max_damage := GetConfigReal(spell_elem, "MaxBaseDamage");

			if ( info.min_damage == error )
				MS_ReportText("Error: No minimum base damage defined for spell_id: "+spell_id+". Using: 0.");
				info.min_damage := 0;
			endif

			if ( info.max_damage == error )
				MS_ReportText("Error: No maximum base damage defined for spell_id: "+spell_id+". Using: 0.");
				info.max_damage := 1;
			endif

			if ( info.min_damage > info.max_damage )
				MS_ReportText("Error: Minimum base damage > maximum base damage for spell_id: "+spell_id+". Using: 0.");
				info.min_damage := 0;
				info.max_damage := 0;
			endif
		endif

		var script := Start_Script(spell_elem.SpellScript, {mobile, info});

		if ( script.errortext )
			if ( mobile.npctemplate )
				PrintTextAbove(mobile, "Unable to start ["+spell_elem.SpellScript+"] -> "+script.errortext);
			else
				SendSysMessage(mobile, "Unable to start ["+spell_elem.SpellScript+"] -> "+script.errortext);
			endif
		endif

		var ev;

		// Loop here and wait for events from the script
		while ( script.pid && !ev )
			ev := wait_for_event(1);
		endwhile
	else
		PlaySoundEffect(mobile, SFX_SPELL_FAIL);
		SendSysMessage(mobile, "The spell fizzles.");
	endif

	MS_SpellDebug(mobile, "Spell starter completed.");
	EraseObjProperty(mobile, "#Casting");

	return 1;
endprogram

function EquipmentCheck(mobile)
	var hand1 := GetEquipmentByLayer(mobile, LAYER_HAND1);
	var hand2 := GetEquipmentByLayer(mobile, LAYER_HAND2);

	// On OSI there are spell weaving weapons that mages can hold while casting spells
	// But they are not implemented yet. Maybe later.
	if ( (hand2 && !hand1.IsA(POLCLASS_SPELLBOOK)) || (hand2 && !hand2.IsA(POLCLASS_SPELLBOOK)) )
		return 0;
	endif

	return 1;
endfunction

function CheckReagents(mobile, byref spell_elem, scroll)
	if ( mobile.npctemplate )
		// NPCs don't need reagents to cast.
		return 1;
	elseif ( scroll.IsA(POLCLASS_ITEM) )
		return SubtractAmount(scroll, 1);
	elseif ( scroll == 1 )
		// Scroll == 1 when called from runebooks, wands, etc to bypass reg requirements
		return 1;
	endif

	var reg_cost := GetConfigStringDictionary(spell_elem, "RegCost");

	// Before consuming, verify that there are enough regs.
	foreach amount in (reg_cost)
		amount := CInt(amount);
		if ( !amount )
			amount := 1;
		endif

		var objtype := GetObjTypeByName(_amount_iter);
		var properties := dictionary{"objtype"->objtype};

		if ( AmountInContainer(mobile.backpack, properties) < amount )
			if ( mobile.cmdlevel )
				SendSysMessage(mobile, "You do not have enough "+GetObjTypeDesc(objtype, (amount>1))+".");
			endif
			return 0;
		endif

		SleepMS(2);
	endforeach
	// Consume reagents - CInt() and < 1 checks already done in previous loop.
	// Foreach is a pointer!
	foreach amount in (reg_cost)
		ConsumeSubstance(mobile.backpack, GetObjTypeByName(_amount_iter), amount);
		SleepMS(2);
	endforeach

	return 1;
endfunction

function FailSpell(mobile)
	mobile.frozen := 0;
	EraseObjProperty(mobile, "#Medding");
	EraseObjProperty(mobile, "#Casting");

	// The fizzle GFX is not suposed to play unless interrupted
	PlaySoundEffect(mobile, SFX_SPELL_FAIL);
	return 1;
endfunction
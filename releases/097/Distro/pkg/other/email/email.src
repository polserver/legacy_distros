/* $Id$
 *
 */

use uo;
use os;

include ":datafile:datafile";
include ":email:gumps";
include ":email:settings";

//Global because its just easier.
var email_data_file := DFOpenDataFile(":email:emails", DF_CREATE);
var address_data_file := DFOpenDataFile(":email:AddressBooks", DF_CREATE);
var blocked_data_file := DFOpenDataFile(":email:BlockLists", DF_CREATE);

var settings := EML_GetSettingsCfgElem("Settings");

unload_scripts("email");
program EmailClient(params)
	var mobile := params[1];
	var box_id := params[2];
	//var send_to := params[3];
	//var subject := params[4];
	//var message := params[5];
	params := 0; // Not needed anymore.

	//if ( send_to )
		/*if ( message )
			if ( Lower(TypeOf(message)) != "array" )
				message := GFWordWrap(message, 595);
			endif
			SendMail(mobile, send_to, subject, message);
		else
			NewLetter(mobile, send_to, subject);
		endif*/
	//else
		IndexGump(mobile, box_id);
	//endif

	return 1;
endprogram

function IndexGump(mobile, box_id)
	var mail_elem := DFFindElement(email_data_file, Hex(box_id), DF_CREATE);
	var gump := BuildInboxGump(box_id, mail_elem);

	while ( mobile.connected )
		var input := GFSendGump(mobile, gump);
		if ( input[UPDATE_INBOX_BTN] )
			mail_elem := DFFindElement(email_data_file, Hex(box_id), DF_CREATE);
			gump := BuildInboxGump(box_id, mail_elem);
		elseif ( input[DELETE_ALL_BTN] )
			foreach mail_number in ( mail_elem.PropNames() )
				if ( mail_number != "NewMsg" )
					mail_elem.EraseProp(Hex(mail_number));
				endif
				SleepMS(2);
			endforeach
		elseif ( input[BLOCK_LIST_BTN] )
			BlockList(mobile, box_id);
		elseif ( input[ADDRESS_BOOK_BTN] )
			AddressBook(mobile, box_id);
		elseif ( input[NEW_LETTER_BTN] )
			ComposeEmail(mobile);
		else
			SendSysMessage(mobile, "Cancelled.");
			break;
		endif
	endwhile

	return 1;
endfunction

function BlockList(mobile, box_id)
	var data_elem := DFFindElement(blocked_data_file, Hex(box_id), DF_CREATE);

	var entry_list := array;
	var gump := BuildBlockListGump(data_elem, entry_list);

	var input := GFSendGump(mobile, gump);

	if ( input[UPDATE_LIST_BTN] )
		var entry_num := 1;
		for ( entry_num; entry_num<=settings.BlockListEntries; entry_num+=1 )
			var block_id := GFExtractData(input, entry_list[entry_num].boxid);
			var name := GFExtractData(input, entry_list[entry_num].name);

			if ( block_id == error )
				continue;
			elseif ( name == error )
				continue;
			endif

			data_elem.SetProp(Hex(entry_num), struct{"boxid":=block_id, "name":=name});
			SleepMS(2);
		endfor
	elseif ( input[DELETE_ALL_BTN] )
		foreach propname in ( data_elem.PropNames() )
			data_elem.EraseProp(propname);
			SleepMS(2);
		endforeach
	endif

	return 1;
endfunction

function AddressBook(mobile, box_id)
	var data_elem := DFFindElement(address_data_file, Hex(box_id), DF_CREATE);

	var entry_list := array;
	var gump := BuildAddressBookGump(data_elem, entry_list);

	var input := GFSendGump(mobile, gump);

	if ( input[UPDATE_LIST_BTN] )
		var entry_num := 1;
		for ( entry_num; entry_num<=settings.AddressBookEntries; entry_num+=1 )
			var block_id := GFExtractData(input, entry_list[entry_num].boxid);
			var name := GFExtractData(input, entry_list[entry_num].name);

			if ( block_id == error )
				continue;
			elseif ( name == error )
				continue;
			endif

			data_elem.SetProp(Hex(entry_num), struct{"boxid":=block_id, "name":=name});
			SleepMS(2);
		endfor
	elseif ( input[DELETE_ALL_BTN] )
		foreach propname in ( data_elem.PropNames() )
			data_elem.EraseProp(propname);
			SleepMS(2);
		endforeach
	endif

	return 1;
endfunction

function ComposeEmail(mobile)
	var gump := BuildComposeGump();

	var input := GFSendGump(mobile, gump);

	return 1;
endfunction
/* $Id$
 *
 */

use uo;
use os;
use boat;
use cfgfile;

include ":boat:cmdParser";
include "include/sysEvent";
include "include/sounds";

program BoatController(boat)
	var last_sound := 0;
	var sleep_mode := 0;
	var cur_cmd := 0;
	var cmd_cfg;
	var cmd_list;

	if ( !Initialize(boat, cmd_cfg, cmd_list) )
		return 0;
	endif

	while ( boat )
		var ev;

		if ( sleep_mode )
			if ( last_sound < POLCore().systime-120 )
				PlaySoundEffect(boat, SFX_WAVE_2);
				last_sound := POLCore().systime;
			endif

			ev := Wait_For_Event(120);
		else
			ev := Wait_For_Event(0);
			var delay := (boat.tillerman).GetSpeed();
			SleepMS(delay);
		endif

		if ( ev || cur_cmd )
			ProcessEvent(boat, ev, cur_cmd, cmd_cfg, cmd_list);
			if ( cur_cmd )
				sleep_mode := 0;
			endif
		elseif ( ShouldSleep(cur_cmd) )
			sleep_mode := 1;
		endif

	endwhile

	return 1;
endprogram

function ProcessEvent(boat, byref ev, byref cur_cmd, byref cmd_cfg, byref cmd_list)
	if ( ev.text )
		if ( (boat.tillerman).IsOnBoat(boat, ev.source) )
			if ( (boat.tillerman).CanCommand(ev.source) )
				var commands := ParseCommands(ev.text, cmd_list);
				if ( commands.Size() <= 0 )
					return 0;
				endif

				PrintTextAbove(boat.tillerman, "Aye captain.");
				foreach command in ( commands )
					var new_cmd := cmd_cfg[command];
					DoCommand(boat, cur_cmd, new_cmd);
					SleepMS(2);
				endforeach
			endif

			return 0;
		endif

		return 0;
	elseif ( cur_cmd )
		DoCommand(boat, cur_cmd, cur_cmd);
	endif

	return 1;
endfunction

function Initialize(boat, byref cmd_cfg, byref cmd_list)
	cmd_cfg := ReadConfigFile(":boat:commands");
	if ( !cmd_cfg )
		PrintTextAbove(boat, "Unable to open config :boat:commands ->"+cmd_cfg.errortext);
		return 0;
	endif
	cmd_list := GetConfigStringArray(cmd_cfg["Heirarchy"], "CMD");
	if ( !cmd_list )
		PrintTextAbove(boat, "Unable to load command list heirarchy. "+cmd_list.errortext);
		return 0;
	endif

	SetObjProperty(boat.tillerman, "#PID", GetPid());

	if ( !(boat.tillerman).GetOwner() )
		SetName(boat.tillerman, "a tiller man [awaiting owner]");
		while ( !(boat.tillerman).GetOwner() )
			Sleep(2);
		endwhile
		var name := (boat.tillerman).desc;
		name[" [awaiting owner]"] := "";
		SetName(boat.tillerman, name);
	endif

	// Ensures the boat only listens as far as it needs to from its mid-point (usually the mast)
	var foot_print := boat.footprint;
	var bow_dist := CoordinateDistance(foot_print.xmin, foot_print.ymin, boat.x, boat.y);
	var stern_dist := CoordinateDistance(foot_print.xmax, foot_print.ymax, boat.x, boat.y);
	if ( bow_dist > stern_dist )
		foot_print := bow_dist;
	else
		foot_print := stern_dist;
	endif
	RegisterForSpeechEvents(boat, foot_print);

	return 1;
endfunction

function ShouldSleep(byref cur_cmd)
	if ( Events_Waiting() )
		return 0;
	elseif ( cur_cmd )
		return 0;
	else
		return 1;
	endif
endfunction

function DoCommand(byref boat, byref cur_cmd, byref new_cmd)
	if ( new_cmd.Anchor == 2 )
		if ( !(boat.tillerman).IsAnchored() )
			(boat.tillerman).SetAnchorStatus(1);
			PrintTextAbove(boat.tillerman, "The anchor has been lowered.");
		else
			PrintTextAbove(boat.tillerman, "The anchor has already been lowered.");
		endif
		return 0;
	elseif ( new_cmd.Anchor == 1 )
		if ( (boat.tillerman).IsAnchored() )
			(boat.tillerman).SetAnchorStatus(0);
			PrintTextAbove(boat.tillerman, "The anchor has been raised.");
		else
			PrintTextAbove(boat.tillerman, "The anchor is already raised.");
		endif
		return 0;
	endif

	if ( !(boat.tillerman).IsAnchored() )
		if ( new_cmd.Turn )
			ClosePlanks(boat);
			TurnBoat(boat, new_cmd.Turn);
			// Maintain the current command.
		endif

		if ( new_cmd.Move )
			var orig_x := boat.x;
			var orig_y := boat.y;
			MoveBoatRelative(boat, new_cmd.Direction);
			if ( orig_x == boat.x && orig_y == boat.y )
				// Unable to move.
				PrintTextAbove(boat.tillerman, "Arrr we hit land!");
				return 0;
			endif

			CheckWorldWrap(boat);

			// Keep following this command
			cur_cmd := new_cmd;
		endif

		if ( new_cmd.Stop )
			cur_cmd := 0;
		endif
	endif

	return 1;
endfunction

function CheckWorldWrap(boat)
	var wrap_cfg := ReadConfigFile(":boat:worldWrap");
	if ( !wrap_cfg )
		return 0;
	endif

	var realm_elem := wrap_cfg[boat.realm];
	if ( !realm_elem )
		return 0;
	endif

	var new_x := boat.x;
	var new_y := boat.y;

	if ( boat.x >= realm_elem.MaxX )
		new_x := realm_elem.MinX;
	elseif ( boat.x <= realm_elem.MinX )
		new_x := realm_elem.MaxX;
	elseif ( boat.y >= realm_elem.MaxY )
		new_y := realm_elem.MinY;
	elseif ( boat.y <= realm_elem.MinY )
		new_y := realm_elem.MaxY;
	else
		return 0;
	endif

	var result := MoveObjectToLocation(boat, new_x, new_y, boat.z, boat.realm);
	if ( result.errortext )
		PrintTextAbove(boat.tillerman, "Unable to move to "+new_x+" "+new_y+" "+boat.z+" "+boat.realm);
		PrintTextAbove(boat.tillerman, "Reason ->"+result.errortext);
	else
		PrintTextAbove(boat.tillerman, "Yar.. around tha' world we go!");
	endif

	return result;
endfunction

function ClosePlanks(byref boat)
	var plank_a := boat.starboardplank;
	var plank_b := boat.portplank;

	if ( plank_a.Extended() )
		plank_a.Retract();
	endif

	if ( plank_b.Extended() )
		plank_b.Retract();
	endif

	return 1;
endfunction

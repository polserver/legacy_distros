//////////////////////////////////////////
//
//   SpawnNet Script v0.95b (2000/10/22)
//
//     based on SpawnNet v0.95b
//       Author: Louds
//       eMail : louds.geo@yahoo.com
//
//     Author: Shinigami
//     eMail : Shinigami@gmx.net
//
//   Modifications:
//     2000/10/19 Shinigami: ReWrite
//
//////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//  Version 0.9.5b	Test
//  Creator: Louds
//  Contact: louds.geo@yahoo.com
//  Spawnnet.src: Core script of the system, control all runes and create all
//                NPCs or items.
//  what's new:
//	0.6: Blaize's new gump (that's way better than the old one)
//	     Spawns can be anchored to the rune (Blaize)
//	     Note field on the runes (Blaize)
//	     Optimized a lot the spawn core (Louds)
//	     Lots of commands (Louds and Blaize)
//	0.7: New template structure (anchor out, flags in)
//	     Basic support to item spawn
//	     Basic support to container spawn
//	     Quest spawn only added skel, not working
//	     Huge code sintax clean up
//	     New rune gump features
//	     Huge code checking added to rune script
//	     Few bug fixes, hope the overspawn bug is gone
//	     Conversion cmd and a few other
//	     Few features are not working fine as I wanted, coming ver 0.8
//	0.8: Bug fixing and code tweaking.
//	0.9: New code structure, some bug fixes
//	0.9.1: huge code speed-up(75%)
//	       support for itemgroup
//	       revamped item spawn
//	       support for item in container spawn
//	       container spawn redesigned
//	       needs a huge work on sspawn
//	       anchoring percentage and other options to be implemented
//	0.9.2: new desing for item and container spawn new implementation done
//	       start-up changed, now needs some debugging
//	0.9.3: now npc creation is 100%
//	       some config features implemented
//	       sspawnr.src changed
//	0.9.4: last test release, can be thought as A candidate release
//		 containers now decay
//		 some problems with container spawn fixed, small speed up
//		 few small fixed and some bug prone code changed
//		 other small random changes
//		 dspawnr now handle all rune tipes
//	0.9.5: more fixes and a small speed up
//		 container spawn fix
//
////////////////////////////////////////////////////////////////////////////////

//////////////
// Libraries
//////////////

Use uo;
Use os;
Use util;
Use cfgfile;

/////////////
// Includes
/////////////

Include "include/spawnnet";
Include "include/starteqp";

//////////////
// Constants
//////////////

Const MsgLanguage:=1; // 1=German, 0=English

Const SPAWNNET_PRIORITY:=30;
Const MAXSPAWNPERCYCLE_DEFAULT:=5;
Const CHAOS_EFFECT_CHANGE_DEFAULT:=5;
Const CONTAINER_TRAP_CHANGE_DEFAULT:=10;
Const MAX_CREATE_TRYES_DEFAULT:=4;
Const START_OPT_DEFAULT:=0;
Const SECS_PER_CYCLE_DEFAULT:=60;
Const CYCLE_TIME_DIVIDER_DEFAULT:=1;

/////////////////////
// Global Variables
/////////////////////
//
// cfg    - Reference to "groups.cfg"
// icfg   - Reference to "igroups.cfg"
// config - Reference to Config-Elem in "config.cfg"
//
// maxspawnpercycle      - Configvalue
// chaos_effect_chance   - Configvalue
// container_trap_chance - Configvalue
// max_create_tryes      - Configvalue
// start_opt             - Configvalue
// secs_per_cycle        - Configvalue
// cycle_time_divider    - Configvalue
//
// forbidden_items - Verbotene Items
//
// spawnnet   -
// queue      - Array, welches den Zeitplan enthaelt. jedes element ist ein array mit alle abzuarbeitenden Runen
// serial     - Array, welches fuer jede Rune die Serial der Rune enthaelt -> SetRune
// x          - Array, welches fuer jede Rune die X-Koordinate der Rune enthaelt (ist ein Indikator fuer existenz der Rune) -> SetRune
// y          - Array, welches fuer jede Rune die Y-Koordinate der Rune enthaelt -> SetRune
// templateb  - Array, welches fuer jede Rune CProp "Template" enthaelt ('ne Zahl / wenn die Rune Typ=1 ist, dann enthaelt es alle "Spawn" gemaess dem Template in der groups.cfg) -> SetRune
// mintime    - Array, welches fuer jede Rune CProp "MinTime" enthaelt           -> SetRune
// maxtime    - Array, welches fuer jede Rune CProp "MaxTime" enthaelt           -> SetRune
// range      - Array, welches fuer jede Rune CProp "Range" enthaelt             -> SetRune
// maxamount  - Array, welches fuer jede Rune CProp "MaxAmount" enthaelt (max. Anzahl NPCs) -> SetRune
// aux        - Array, welches fuer jede Rune CProp "Aux" enthaelt, jedoch fuer
//              ContainerSpawnRunen die Seriennummer des Containers -> SetRune
// type       - Array, welches fuer jede Rune das 1. Nibble der CProp "Flags" enthaelt (Runentyp) -> SetRune
// flags      - Array, welches fuer jede Rune das 2. Nibble der CProp "Flags" enthaelt (???) -> SetRune
// amountnum  - Array, welches fuer jede Rune das 3. Nibble der CProp "Flags" enthaelt (??? min. 1) -> SetRune
// amount     - Array, welches fuer jede Rune die Anzahl der gefundenen NPCs enthaelt

// Groups.cfg einlesen, ggf. cachen

Global cfg:=ReadConfigFile("groups");
If (!cfg)
  If (MsgLanguage)
    SysLog("SpawnNet: Kann die Datei 'groups.cfg' nicht oeffnen!");
  Else
    SysLog("SpawnNet: Can't open file 'groups.cfg'!");
  EndIf
  Return;
EndIf
//Cache(cfg);
//UnloadConfigFile("groups");

// iGroups.cfg einlesen, ggf. cachen

Global icfg:=ReadConfigFile("igroups");
If (!icfg)
  If (MsgLanguage)
    SysLog("SpawnNet: Kann die Datei 'igroups.cfg' nicht oeffnen!");
  Else
    SysLog("SpawnNet: Can't open file 'igroups.cfg'!");
  EndIf
  Return;
EndIf
//Cache(icfg);
//UnloadConfigFile("igroups");

// Konfigurationsdaten aus der Config.cfg einlesen

Global config:=ReadConfigFile("config");
If (config)
  config:=FindConfigElem(config, 1);
  If (!config)
    If (MsgLanguage)
      SysLog("SpawnNet: Kann 'config' nicht in 'config.cfg' finden!");
    Else
      SysLog("SpawnNet: Can't find key 'config' in file 'config.cfg'!");
    EndIf
    Return;
  EndIf
Else
  If (MsgLanguage)
    SysLog("SpawnNet: Kann die Datei 'config.cfg' nicht oeffnen!");
  Else
    SysLog("SpawnNet: Can't open file 'config.cfg'!");
  EndIf
  Return;
EndIf

Global maxspawnpercycle:=GetIntValue(config.maxspawnpercycle, MAXSPAWNPERCYCLE_DEFAULT);
Global chaos_effect_change:=GetIntValue(config.chaoseffectchance, CHAOS_EFFECT_CHANGE_DEFAULT);
Global container_trap_change:=GetIntValue(config.trapchance, CONTAINER_TRAP_CHANGE_DEFAULT);
Global max_create_tryes:=GetIntValue(config.maxtryes, MAX_CREATE_TRYES_DEFAULT);
Global start_opt:=GetIntValue(config.faststart, START_OPT_DEFAULT);
Global secs_per_cycle:=GetIntValue(config.secs_per_cycle, SECS_PER_CYCLE_DEFAULT);
Global cycle_time_divider:=CInt(config.cycle_time_divider);
If ((!cycle_time_divider) Or (cycle_time_divider<1))
  cycle_time_divider:=CYCLE_TIME_DIVIDER_DEFAULT;
EndIf

UnloadConfigFile("config");

// Verbotene Items definieren

Global forbidden_items:={0xa300, 0xa350, 0xa340};

// Hauptvariablen deklarieren

Global queue:={ };
Global templateb:={ };
Global x:={ };
Global y:={ };
Global mintime:={ };
Global maxtime:={ };
Global range:={ };
Global maxamount:={ };
Global amount:={ };
Global type:={ };
Global flags:={ };
Global amountnum:={ };
Global serial:={ };
Global aux:={ };

////////////////
// Mainprogram
////////////////

Program SpawnNet()
  If (MsgLanguage)
    BroadCast("SpawnNet wird aktiviert...");
    SysLog("SpawnNet wird aktiviert...");
  Else
    BroadCast("Activating SpawnNet...");
    SysLog("Activating SpawnNet...");
  EndIf

  // Start up sequence
  //  find all runes on the world, their spawn childs and if it's item container
  //  spawn look-up for it's container (phase out if missing). this function
  //  will be hugely optimized on the near future, using a runeserial look-up,
  //  leaving just the npc look-up the auto-heal start-up will still remain,
  //  but will be triggered by a cfg entry. the runes shrink will be cfg
  //  triggered too, since it's damn heavy, specialy due container/item spawn

  // Suche nach den Runen
  /////////////////////////

/*obj                - aktuelles Item/NPC in der Welt
  spawnnet           - CProp des Item/NPC, welches die SpawnRunenNummer enthaelt
  amount             - Array, welches fuer jede Rune die Anzahl der gefundenen
                       gespawnten NPCs enthaelt
  x                  - Array, welches fuer jede Rune die X-Koordinate der Rune enthaelt
                       (wird in SetRune gesetzt)
  y                  - Array, welches fuer jede Rune die Y-Koordinate der Rune enthaelt
                       (wird in SetRune gesetzt)
  inside_item        - Items im Inneren eines Containers
  aux                - Array, welches fuer jede Rune innerhalb eines Containers die
                       Seriennummer der selbigen enthaelt
  contspawnnet       - Nummer der SpawnRune, die sich in'nem Container befindet
  contspawnrunefound - Wurde die Rune innerhalb des Containers gefunden?
  cntserial          - Seriennummer des Containers fuer das ContainerSpawning
                       (in dem befindet sich auch die SpawnRune)
  emptycontainer     - Array, das alle SpawnContainer auflistet, in denen die Rune fehlt*/

  Local emptycontainer:={ };
  Local spawnnet;
  ForEach obj in ListObjectsInBox(0, 0, -128, 6143, 4095, 128)
    spawnnet:=CInt(GetObjProperty(obj, "spawnnet"));
    If (spawnnet)                         // Wird es vom SpawnNet verwaltet ?
      If ((obj.amount) Or (obj.amount=0)) // Ist es ein Item?
        If (obj.objtype=0xa300)   // Ist es eine SpawnRune?
          If (x[spawnnet]) // Gibt es die Rune mit der Nummer schon ?
            If (MsgLanguage)
              SysLog("SpawnNet: Folgende Runen haben die gleiche Nummer: ("+
                obj.x+", "+obj.y+") und ("+x[spawnnet]+", "+y[spawnnet]+") !");
            Else
              SysLog("SpawnNet: Rune ("+obj.x+", "+obj.y+") and Rune ("+
                x[spawnnet]+", "+y[spawnnet]+") use the same Number!");
            EndIf
          Else
            SetRune(spawnnet, obj);
          EndIf
        Else // gespawnter Container, oder ein Container mit SpawnRune
          If ((obj.locked) Or (obj.locked=0)) // Ist es ein Container?
            Local contspawnrunefound:=0;
            Local contspawnnet;

            ForEach inside_item in EnumerateItemsInContainer(obj)
              If (inside_item.objtype=0xa300) // Root Runen Container
                contspawnnet:=CInt(GetObjProperty(inside_item, "spawnnet"));
                If (contspawnnet) // Aktive Rune
                  If (spawnnet=contspawnnet) // Ist eine ContainerSpawnRune
                    SetRune(contspawnnet, inside_item);
                    contspawnrunefound:=1;

                    Local cntserial:=CInt(GetObjProperty(inside_item, "aux"));
                    If (cntserial<>obj.serial)
                      If (MsgLanguage)
                        SysLog("SpawnNet: Die Rune befindet sich im falschen "+
                          "Container ("+obj.x+", "+obj.y+"), gefixt !");
                      Else
                        SysLog("SpawnNet: Rune is in the wrong Container ("+
                          obj.x+", "+obj.y+"), fixed !");
                      EndIf

                      Local runeobj:=SystemFindObjectBySerial(serial[contspawnnet]);
                      If (runeobj)
                        aux[contspawnnet]:=obj.serial;
                        SetObjProperty(runeobj, "aux", obj.serial);
                      Else
                        If (MsgLanguage)
                          SysLog("SpawnNet: Die Rune ("+x[contspawnnet]+", "+y[contspawnnet]+") hat sich verfluechtigt!");
                        Else
                          SysLog("SpawnNet: Rune ("+x[contspawnnet]+", "+y[contspawnnet]+") is gone away!");
                        EndIf
                      EndIf
                    EndIf
                  Else
                    If (MsgLanguage)
                      SysLog("SpawnNet: Die Rune befindet sich faelschlicherweise in einem "+
                        "Container ("+obj.x+", "+obj.y+") !");
                    Else
                      SysLog("SpawnNet: Rune shouldn't be in a Container ("+obj.x+", "+obj.y+") !");
                    EndIf
                  EndIf
                EndIf
              EndIf
            EndForEach

            If (!contspawnrunefound) // Im SpawnContainer fehlt die SpawnRune...
              emptycontainer.append({obj, spawnnet});
            EndIf
          EndIf
        EndIf
      Else // Ist ein gespawnter NPC
        If (amount[spawnnet])
          amount[spawnnet]:=amount[spawnnet]+1;
        Else
          amount[spawnnet]:=1;
        EndIf
      EndIf
    EndIf

    SleepMS(5);
  EndForEach

  // Behandlung der Container ohne Rune
  ///////////////////////////////////////

  ForEach cnt in emptycontainer
    If (x[cnt[2]]) // Gibt es die Rune mit der Nummer schon ?
      If (type[cnt[2]]=3)
        If (aux[cnt[2]]) // Ist der Container schon eingetragen?
          If (aux[cnt[2]]<>cnt[1].serial)
            If (MsgLanguage)
              SysLog("SpawnNet: Die ContainerSpawnRune ("+x[cnt[2]]+", "+y[cnt[2]]+") hat mehrere Container ("+cnt[1].x+", "+cnt[1].y+") gespawnt!");
            Else
              SysLog("SpawnNet: ContainerSpawnRune ("+x[cnt[2]]+", "+y[cnt[2]]+") has spawned more then 1 Container ("+cnt[1].x+", "+cnt[1].y+") !");
            EndIf
          EndIf
        Else
          Local runeobj:=SystemFindObjectBySerial(serial[cnt[2]]);
          If (runeobj)
            aux[cnt[2]]:=cnt[1].serial;
            SetObjProperty(runeobj, "aux", cnt[1].serial);
          Else
            If (MsgLanguage)
              SysLog("SpawnNet: Die ContainerSpawnRune ("+x[cnt[2]]+", "+y[cnt[2]]+") hat sich verfluechtigt!");
            Else
              SysLog("SpawnNet: ContainerSpawnRune ("+x[cnt[2]]+", "+y[cnt[2]]+") is gone away!");
            EndIf
          EndIf
        EndIf
      ElseIf (type[cnt[2]]=2)
        If (flags[cnt[2]][2]) // Ist Bit 1 gesetzt? -> InContainerSpawn
          If (MsgLanguage)
            SysLog("SpawnNet: Die InContainerSpawnRune ("+x[cnt[2]]+", "+y[cnt[2]]+") befindet sich ausserhalb ihres Containers ("+cnt[1].x+", "+cnt[1].y+") !");
          Else
            SysLog("SpawnNet: InContainerSpawnRune ("+x[cnt[2]]+", "+y[cnt[2]]+") should be inside the Container ("+cnt[1].x+", "+cnt[1].y+") !");
          EndIf
        EndIf
      Else
        If (MsgLanguage)
          SysLog("SpawnNet: Die SpawnRune zum Container ("+x[cnt[2]]+", "+y[cnt[2]]+") hat den falschen Typ!");
        Else
          SysLog("SpawnNet: SpawnRune for Container ("+x[cnt[2]]+", "+y[cnt[2]]+") has wrong Type!");
        EndIf
      EndIf
    Else
      If (MsgLanguage)
        SysLog("SpawnNet: Es gibt keine Rune zum Container ("+cnt[1].x+", "+cnt[1].y+") !");
      Else
        SysLog("SpawnNet: Where's the Rune for Container ("+cnt[1].x+", "+cnt[1].y+") ?");
      EndIf
    EndIf
  EndForEach
  emptycontainer:={ };

  // Global Properties initialisieren
  /////////////////////////////////////

  SetGlobalProperty("deletedpool", { });
  SetGlobalProperty("deathpool", { });
  SetGlobalProperty("refreshpool", { });
  SetGlobalProperty("runeserial", { });

  // Fuellt den Zeitpuffer mit allen Runen
  //////////////////////////////////////////

  StartQueue(); // Fuellt den Zeitpuffer mit allen Runen

  If (MsgLanguage)
    BroadCast("SpawnNet wurde initialisiert.");
    SysLog("SpawnNet wurde initialisiert.");
  Else
    BroadCast("SpawnNet activated.");
    SysLog("SpawnNet activated.");
  EndIf

  ///////////////////
  // Hauptschleife //
  ///////////////////

  Set_Priority(SPAWNNET_PRIORITY);

  Local pool;
  While (1)
    // DeletePool check
    //  this part of the code takes care of all deleded runes,
    //  phasing'em down by setting its runes.x to 0

    // DeletePool abarbeiten
    //////////////////////////

    Set_Critical(1);
    pool:=GetGlobalProperty("deletedpool");
    SetGlobalProperty("deletedpool", { });
    Set_Critical(0);

    ForEach rune in pool
      x[CInt(rune)]:=0;
    EndForEach

    // CreatePool check
    //  here we take care of created runes, adding to the system

    // CreatePool abarbeiten
    //////////////////////////

    Set_Critical(1);
    pool:=GetGlobalProperty("createpool");
    SetGlobalProperty("createpool", { });
    Set_Critical(0);

    Local rune;
    Local runeobj;
    ForEach rune_serial in pool
      runeobj:=SystemFindObjectBySerial(rune_serial);
      If (!runeobj)
        Continue;
      EndIf

      If (GetObjProperty(runeobj, "spawnnet"))
        Continue;
      EndIf

      rune:=y.size()+1;
      amount[rune]:=0;
      SetRune(rune, runeobj);
      SetObjProperty(runeobj, "spawnnet", rune);

      Case (type[rune])
        1: DoNPCSpawn(rune);
        2: DoItemSpawn(rune);
        3: DoContainerSpawn(rune);

        default: If (MsgLanguage)
                   SysLog("SpawnNet: Die Rune ("+runeobj.x+", "+runeobj.y+") besitzt "+
                     "einen ungueltigen Typ ("+type[rune]+") !");
                 Else
                   SysLog("SpawnNet: Rune ("+runeobj.x+", "+runeobj.y+") has unused Type ("+type[rune]+") !");
                 EndIf
      EndCase
    EndForEach

    // DeathPool check
    //  all death npcs appear here, just subtract 1 from it's rune amount

    // DeathPool abarbeiten
    /////////////////////////

    Set_Critical(1);
    pool:=GetGlobalProperty("deathpool");
    SetGlobalProperty("deathpool", { });
    Set_Critical(0);

    ForEach dead in pool
      amount[dead]:=amount[dead]-1;
    EndForEach

    // RefreshPool check
    //  every time you hit save on a online rune, this routine takes care of
    //  updating the info on the system. sure we could just store a itemref,
    //  but this would result on problems open deletion and a major slow down
    //  due heavy use of GetObjProperty() to retrieve data

    // RefreshPool abarbeiten
    ///////////////////////////

    Set_Critical(1);
    pool:=GetGlobalProperty("refreshpool");
    SetGlobalProperty("refreshpool", { });
    Set_Critical(0);

    Local spawnnet;
    ForEach rune_serial in pool
      runeobj:=SystemFindObjectBySerial(rune_serial);
      If (!runeobj)
        Continue;
      EndIf

      spawnnet:=GetObjProperty(runeobj, "spawnnet");
      If (spawnnet)
        SetRune(spawnnet, runeobj);
      EndIf
    EndForEach

    // Timer Look-Up
    //  this will speed things a lot since there's no need to do a rune loop
    //  every time cicle this should also solve some item spawn problem, now
    //  they should be hugely faster, thou allowing use of item groups.
    //  container spawn should allow use of makeloot ofter.

    // Spawnen gemaess Queue
    //////////////////////////

    pool:=queue[1]; // Liste der Runen aus der Queue holen und selbige bereinigen
    queue.erase(1);

    ForEach rune in pool
      Case (type[rune])
        1: DoNPCSpawn(rune);
        2: DoItemSpawn(rune);
        3: DoContainerSpawn(rune);
      EndCase
    EndForEach

    // Misc Functions
    //  handles all server functions.
    //  command table:
    //   rune resync -> reload all runes, using runeserial
    //   rune look-up -> reload all runes, search on the world
    //   rune shrink, this compact the database
    //   refresh all rune childs
    //   reload the cfgs, will only work when caching is used
    //   reload config file
    //   reload groups files

    // Sonstige Aufgaben abarbeiten
    /////////////////////////////////

    SetGlobalProperty("runeserial", serial);
    pool:={ };

    Sleep(SECS_PER_CYCLE/CYCLE_TIME_DIVIDER);
  EndWhile
EndProgram

////////////////////////////////////////
// DoNPCSpawn - NPC-Spawn durchfuehren
////////////////////////////////////////
//
// this function spawns npcs and keep their queue time updated
// there's nothing much to change, not until I find use to the

Function DoNPCSpawn(rune)
  If (!x[rune])
    If (MsgLanguage)
      SysLog("SpawnNet: Die NPCSpawnRune ("+rune+") wurde geloescht/deaktiviert!");
    Else
      SysLog("SpawnNet: Deleting/Deactivating NPCSpawnRune ("+rune+") !");
    EndIf
    Return;
  EndIf

  // Naechsten Spawn anstossen
  //////////////////////////////

  Local spawntime:=mintime[rune]+RandomInt(maxtime[rune]-mintime[rune]);
  Local spawnrunes:=queue[spawntime];
  If (!spawnrunes)
    spawnrunes:={ };
  EndIf
  spawnrunes.append(rune);
  queue[spawntime]:=spawnrunes;

  If (!amount[rune])
    amount[rune]:=0;
  EndIf

  If (amount[rune]>=maxamount[rune]) // Sind schon genuch Viechers da
    Return;
  EndIf

  // Spawning durchfuehren
  //////////////////////////

  Local spawnamount:=1;
  If (flags[rune][1]) // Ist Bit 0 gesetzt? -> Grouping
    spawnamount:=amountnum[rune];
    If (spawnamount>(maxamount[rune]-amount[rune]))
      spawnamount:=maxamount[rune]-amount[rune];
    EndIf

    If (spawnamount>MAXSPAWNPERCYCLE)
      spawnamount:=MAXSPAWNPERCYCLE;
    EndIf
  EndIf

  amount[rune]:=amount[rune]+spawnamount;

  Local template:=templateb[rune];
  Local times_height:=0;
  Local times_create:=0;
  Local creature;
  Local spawnx;
  Local spawny;
  Local spawnz;
  Local spawn;
  While (spawnamount)
    spawnx:=x[rune]+RandomInt(range[rune]*2)-range[rune];
    spawny:=y[rune]+RandomInt(range[rune]*2)-range[rune];
    spawnz:=GetWorldHeight(spawnx, spawny);

    If (spawnz.error)
      times_height:=times_height+1;
      If (times_height>MAX_CREATE_TRYES)
        amount[rune]:=amount[rune]-spawnamount;

        If (MsgLanguage)
          SysLog("SpawnNet: Die NPCSpawnRune ("+x[rune]+", "+y[rune]+") konnte keinen geeigneten Platz finden!");
        Else
          SysLog("SpawnNet: NPCSpawnRune ("+x[rune]+", "+y[rune]+") was unable to find a SpawnPlace!");
        EndIf
        Return (0);
      EndIf

      Continue;
    Else
      times_height:=0;
    EndIf

    If (template.size())
      spawn:=template[RandomInt(template.size())+1];
    Else
      spawn:=template;
    EndIf

    creature:=CreateNpcFromTemplate(spawn, 5283, 1184, 0);
    If (creature)
      times_create:=0;
    Else
      times_create:=times_create+1;
      If (times_create>MAX_CREATE_TRYES)
        amount[rune]:=amount[rune]-spawnamount;

        If (MsgLanguage)
          SysLog("SpawnNet: Die NPCSpawnRune ("+x[rune]+", "+y[rune]+") konnte keinen NPC ("+spawn+") spawnen!");
        Else
          SysLog("SpawnNet: NPCSpawnRune ("+x[rune]+", "+y[rune]+") was unable to spawn NPC ("+spawn+") !");
        EndIf
        Return (0);
      EndIf

      Continue;
    EndIf

    SetObjProperty(creature, "spawnnet", rune);
    MoveCharacterToLocation(creature, spawnx, spawny, spawnz, MOVECHAR_FORCELOCATION);

    If (flags[rune][2]=1) // Ist Bit 1 gesetzt? -> Anker
      SetObjProperty(creature, "anchorX", x[rune]);
      SetObjProperty(creature, "anchorY", y[rune]);
      SetObjProperty(creature, "dstart", range[rune]);
      SetObjProperty(creature, "psub", 100/range);

      RestartScript(creature);
    EndIf

    spawnamount:=spawnamount-1;
  EndWhile
EndFunction

//////////////////////////////////////////
// DoItemSpawn - Item-Spawn durchfuehren
//////////////////////////////////////////
//
// this function is itended to only spawn items, in containers or not
// this would bring otimization due the desagregation of container spawn

Function DoItemSpawn(rune)
  If (!x[rune])
    If (MsgLanguage)
      SysLog("SpawnNet: Die ItemSpawnRune ("+rune+") wurde geloescht/deaktiviert!");
    Else
      SysLog("SpawnNet: Deleting/Deactivating ItemSpawnRune ("+rune+") !");
    EndIf
    Return;
  EndIf

  Local contobj;
  If (flags[rune][2]) // Ist Bit 1 gesetzt? -> InContainerSpawn
    contobj:=SystemFindObjectBySerial(aux[rune]); // Container, in dem sich die Rune befindet
    If (contobj)
      ContainerCount(contobj, rune);
    Else
      Local runeobj:=SystemFindObjectBySerial(serial[rune]);
      If ((runeobj) And (runeobj.container))
        contobj:=runeobj.container; // Rune befindet sich doch im Container
        aux[rune]:=contobj.serial;
        SetObjProperty(runeobj, "aux", contobj.serial);
        ContainerCount(contobj, rune);
      Else // irgendwas lief falsch
        DestroyItem(runeobj);
        If (MsgLanguage)
          SysLog("SpawnNet: ItemSpawnRune befand sich nicht in einem Container und wurde geloescht!");
        Else
          SysLog("SpawnNet: Deleting ItemSpawnRune - wasn't inside a Container!");
        EndIf
        x[rune]:=0;
        Return (0);
      EndIf
    EndIf
  Else
    ItemCount(rune);
  EndIf

  // Naechsten Spawn anstossen
  //////////////////////////////

  Local spawntime:=mintime[rune]+RandomInt(maxtime[rune]-mintime[rune]);
  Local spawnrunes:=queue[spawntime];
  If (!spawnrunes)
    spawnrunes:={ };
  EndIf
  spawnrunes.append(rune);
  queue[spawntime]:=spawnrunes;

  If (!amount[rune])
    amount[rune]:=0;
  EndIf

  If (amount[rune]>=maxamount[rune]) // Sind schon genuch Items da
    Return;
  EndIf

  // Spawning durchfuehren
  //////////////////////////

  Local spawnamount:=1;
  If (flags[rune][1]) // Ist Bit 0 gesetzt? -> Grouping
    spawnamount:=amountnum[rune];
    If (spawnamount>(maxamount[rune]-amount[rune]))
      spawnamount:=maxamount[rune]-amount[rune];
    EndIf

    If (spawnamount>MAXSPAWNPERCYCLE)
      spawnamount:=MAXSPAWNPERCYCLE;
    EndIf
  EndIf

  Local stackamount:=1;
  If (!flags[rune][2]) // Ist Bit 1 gesetzt? -> InContainerSpawn
    stackamount:=aux[rune]; // StackMenge
  EndIf

  amount[rune]:=amount[rune]+spawnamount;

  Local template:=templateb[rune];
  Local times_height:=0;
  Local times_create:=0;
  Local spawnx;
  Local spawny;
  Local spawnz;
  Local spawn;
  Local item;
  While (spawnamount)
    If (template.size())
      spawn:=template[RandomInt(template.size())+1];
    Else
      spawn:=template;
    EndIf

    If (flags[rune][2]) // Ist Bit 1 gesetzt? -> InContainerSpawn
      item:=CreateItemInContainer(contobj, spawn, stackamount);
      If (item)
        times_create:=0;
      Else
        item:=CreateItemInContainer(contobj, spawn, 1);
        If (item)
          Local i;
          For (i:=2; i<=stackamount; i:=i+1)
            CreateItemInContainer(contobj, spawn, 1);
          EndFor
        Else
          times_create:=times_create+1;
          If (times_create>MAX_CREATE_TRYES)
            amount[rune]:=amount[rune]-spawnamount;

            If (MsgLanguage)
              SysLog("SpawnNet: Die ItemSpawnRune ("+x[rune]+", "+y[rune]+") konnte kein Item ("+spawn+") spawnen!");
            Else
              SysLog("SpawnNet: ItemSpawnRune ("+x[rune]+", "+y[rune]+") was unable to spawn Item ("+spawn+") !");
            EndIf
            Return (0);
          EndIf

          Continue;
        EndIf
      EndIf

      SetObjProperty(item, "spawnnet", rune);
    Else
      spawnx:=x[rune]+RandomInt(range[rune]*2)-range[rune];
      spawny:=y[rune]+RandomInt(range[rune]*2)-range[rune];
      spawnz:=GetWorldHeight(spawnx, spawny);

      If (spawnz.error)
        times_height:=times_height+1;
        If (times_height>MAX_CREATE_TRYES)
          amount[rune]:=amount[rune]-spawnamount;

          If (MsgLanguage)
            SysLog("SpawnNet: Die ItemSpawnRune ("+x[rune]+", "+y[rune]+") konnte keinen geeigneten Platz finden!");
          Else
            SysLog("SpawnNet: ItemSpawnRune ("+x[rune]+", "+y[rune]+") was unable to find a SpawnPlace!");
          EndIf
          Return (0);
        EndIf

        Continue;
      Else
        times_height:=0;
      EndIf

      If (!flags[rune][4]) // Ist Bit 3 gesetzt? -> Alte Items erhalten
        ForEach olditem in ListItemsAtLocation(spawnx, spawny, spawnz)
          If ((olditem.objtype<>0xa300) And (GetObjProperty(olditem, "spawnnet")=rune))
            DestroyItem(olditem);
          EndIf
        EndForEach
      EndIf

      item:=CreateItemAtLocation(spawnx, spawny, spawnz, spawn, stackamount);
      If (item)
        times_create:=0;
      Else
        item:=CreateItemAtLocation(spawnx, spawny, spawnz, spawn, 1);
        If (item)
          Local i;
          For (i:=2; i<=stackamount; i:=i+1)
            CreateItemAtLocation(spawnx, spawny, spawnz, spawn, 1);
          EndFor
        Else
          times_create:=times_create+1;
          If (times_create>MAX_CREATE_TRYES)
            amount[rune]:=amount[rune]-spawnamount;

            If (MsgLanguage)
              SysLog("SpawnNet: Die ItemSpawnRune ("+x[rune]+", "+y[rune]+") konnte kein Item ("+spawn+") spawnen!");
            Else
              SysLog("SpawnNet: ItemSpawnRune ("+x[rune]+", "+y[rune]+") was unable to spawn Item ("+spawn+") !");
            EndIf
            Return (0);
          EndIf

          Continue;
        EndIf
      EndIf

      SetObjProperty(item, "spawnnet", rune);
    EndIf

    spawnamount:=spawnamount-1;
  EndWhile
EndFunction

////////////////////////////////////////////////////
// DoContainerSpawn - Container-Spawn durchfuehren
////////////////////////////////////////////////////
//
// first we do check if is there any present container, if not spawn a new
// one them we check its inside and makeloot if the conditions are ok

Function DoContainerSpawn(rune)
  If (!x[rune])
    If (MsgLanguage)
      SysLog("SpawnNet: Die ContainerSpawnRune ("+rune+") wurde geloescht/deaktiviert!");
    Else
      SysLog("SpawnNet: Deleting/Deactivating ContainerSpawnRune ("+rune+") !");
    EndIf
    Return;
  EndIf

  // Naechsten Spawn anstossen
  //////////////////////////////

  Local spawntime:=mintime[rune]+RandomInt(maxtime[rune]-mintime[rune]);
  Local spawnrunes:=queue[spawntime];
  If (!spawnrunes)
    spawnrunes:={ };
  EndIf
  spawnrunes.append(rune);
  queue[spawntime]:=spawnrunes;

  // Container spawnen, falls fehlend
  /////////////////////////////////////

  Local contobj:=SystemFindObjectBySerial(aux[rune]); // Container, der von der Rune erzeugt wurde
  If (!contobj)
    Local spawn:=templateb[rune];
    Local times_height:=0;
    Local times_create:=0;
    Local spawnamount:=1;
    Local spawnx;
    Local spawny;
    Local spawnz;
    While (spawnamount)
      If (flags[rune][1]) // Ist Bit 0 gesetzt? -> Moving Spawn
        spawnx:=x[rune]+RandomInt(range[rune]*2)-range[rune];
        spawny:=y[rune]+RandomInt(range[rune]*2)-range[rune];
      Else
        spawnx:=x[rune];
        spawny:=y[rune];
      EndIf
      spawnz:=GetWorldHeight(spawnx, spawny);

      If (spawnz.error)
        times_height:=times_height+1;
        If (times_height>MAX_CREATE_TRYES)
          If (MsgLanguage)
            SysLog("SpawnNet: Die ContainerSpawnRune ("+x[rune]+", "+y[rune]+") konnte keinen geeigneten Platz finden!");
          Else
            SysLog("SpawnNet: ContainerSpawnRune ("+x[rune]+", "+y[rune]+") was unable to find a SpawnPlace!");
          EndIf
          Return (0);
        EndIf

        Continue;
      Else
        times_height:=0;
      EndIf

      contobj:=CreateItemAtLocation(spawnx, spawny, spawnz, spawn, 1);
      If (contobj)
        times_create:=0;
      Else
        times_create:=times_create+1;
        If (times_create>MAX_CREATE_TRYES)
          If (MsgLanguage)
            SysLog("SpawnNet: Die ContainerSpawnRune ("+x[rune]+", "+y[rune]+") konnte kein Item ("+spawn+") spawnen!");
          Else
            SysLog("SpawnNet: ContainerSpawnRune ("+x[rune]+", "+y[rune]+") was unable to spawn Item ("+spawn+") !");
          EndIf
          Return (0);
        EndIf

        Continue;
      EndIf

      SetObjProperty(contobj, "spawnnet", rune);
      contobj.decayat:=ReadGameClock()+(mintime[rune]+RandomInt(maxtime[rune]-mintime[rune]))*60;

      Local runeobj:=SystemFindObjectBySerial(serial[rune]);
      If (runeobj)
        aux[rune]:=contobj.serial;
        SetObjProperty(runeobj, "aux", contobj.serial);
      Else
        If (MsgLanguage)
          SysLog("SpawnNet: Die Rune ("+x[rune]+", "+y[rune]+") hat sich verfluechtigt!");
        Else
          SysLog("SpawnNet: Rune ("+x[rune]+", "+y[rune]+") is gone away!");
        EndIf
      EndIf

      spawnamount:=spawnamount-1;
    EndWhile
  EndIf

  // Container fuellen
  //////////////////////
  //
  // time to do inside check on the container
  // should we just count spawned items by this rune?

  If (flags[rune][3]) // Ist Bit 2 gesetzt? -> Container leeren
    ForEach olditem in EnumerateItemsInContainer(contobj)
      If (!(olditem.objtype in forbidden_items))
        If (flags[rune][4]) // Ist Bit 3 gesetzt? -> Alte Items erhalten
          If (GetObjProperty(olditem, "spawnnet")<>rune)
            DestroyItem(olditem);
          EndIf
        Else
          DestroyItem(olditem);
        EndIf
      EndIf
    EndForEach
  EndIf

  MakeLoot(contobj, amountnum[rune]);

  If (RandomInt(100)<CONTAINER_TRAP_CHANGE)
    SetObjProperty(contobj, "trap_strength", RandomInt(5)+1);
    SetObjProperty(contobj, "trap_type", CStr(RandomInt(3)+1));
    contobj.usescript:=":traps:traps";
  EndIf
EndFunction

//////////////////////////////////////
// ItemCount - Zaehlt die SpawnItems
//////////////////////////////////////

Function ItemCount(rune)
  Local template:=templateb[rune];
  Local count:=0;

  ForEach item in ListItemsNearLocation(x[rune], y[rune], GetWorldHeight(x[rune], y[rune]), range[rune]+1)
    If ((GetObjProperty(item, "spawnnet")=rune) And (!(item.objtype in forbidden_items)) And
       ((item.objtype=template) Or (item.objtype in template)))
      count:=count+1;
    EndIf
  EndForEach

  amount[rune]:=count;
EndFunction

////////////////////////////////////////////////////////
// ContainerCount - Zaehlt die SpawnItems im Container
////////////////////////////////////////////////////////

Function ContainerCount(contobj, rune)
  Local count:=0;

  ForEach item in EnumerateItemsInContainer(contobj)
    If (((item.container).serial=contobj.serial) And (GetObjProperty(item,
       "spawnnet")=rune) And (!(item.objtype in forbidden_items)))
      count:=count+1;
    EndIf
  EndForEach

  amount[rune]:=count;
EndFunction

//////////////////////////////////
// SetRune - Definiert eine Rune
//////////////////////////////////

Function SetRune(rune, obj)
  serial[rune]:=obj.serial;
  x[rune]:=obj.x;
  y[rune]:=obj.y;

  // Runeneigenschaften der Rune ermitteln
  //////////////////////////////////////////

  templateb[rune]:=GetObjProperty(obj, "template");
  mintime[rune]:=CInt(GetObjProperty(obj, "mintime"))*CYCLE_TIME_DIVIDER;
  maxtime[rune]:=CInt(GetObjProperty(obj, "maxtime"))*CYCLE_TIME_DIVIDER;
  range[rune]:=CInt(GetObjProperty(obj, "range"));
  maxamount[rune]:=CInt(GetObjProperty(obj, "maxamount"));
  aux[rune]:=CInt(GetObjProperty(obj, "aux"));

  // Flags der Rune ermitteln
  /////////////////////////////

  Local runeflags:=CInt(GetObjProperty(obj, "flags"));
  If (runeflags<0x1000)
    runeflags:=0x1000;
    SetObjProperty(obj, "flags", runeflags);
  EndIf
  runeflags:=CStr(Hex(runeflags));

  type[rune]:=CInt("0x"+runeflags[3, 1]);
  flags[rune]:=GetFlags(CInt("0x"+runeflags[4, 1])); // Wandelt 4 Bits in ein Array um

  Local runeamountnum:=CInt("0x"+runeflags[5, 2]);
  If (runeamountnum<1)
    runeamountnum:=1;
  EndIf
  amountnum[rune]:=runeamountnum;

  // Runen gemaess Typ konfigurieren
  ////////////////////////////////////

  Case (type[rune])
    // NPCGroupSpawnRunen -> templateb[rune] mit den spawnbaren Elementen fuettern
    1: If (CInt(templateb[rune]))
         Local spawngroup:=cfg[templateb[rune]];
         If (spawngroup)
           templateb[rune]:=GetConfigStringArray(spawngroup, "spawn");
           If (!templateb[rune])
             If (MsgLanguage)
               SysLog("SpawnNet: Leeres Group-Template ("+spawngroup+") !");
             Else
               SysLog("SpawnNet: Empty Group-Template ("+spawngroup+") !");
             EndIf
             x[rune]:=0;
             Return (0);
           EndIf
         Else
           If (MsgLanguage)
             SysLog("SpawnNet: Group-Template ("+templateb[rune]+") existiert nicht!");
           Else
             SysLog("SpawnNet: Group-Template ("+templateb[rune]+") doesn't exist!");
           EndIf
           x[rune]:=0;
           Return (0);
         EndIf
       EndIf

    // Item[Group][Container]SpawnRunen -> templateb[rune] mit den spawnbaren Elementen fuettern und Container gegenchecken
    2: If (CInt(templateb[rune]))
         Local spawngroup:=icfg[templateb[rune]];
         If (spawngroup)
           Local itemtemplates:=GetConfigStringArray(spawngroup, "item");
           If (!itemtemplates)
             If (MsgLanguage)
               SysLog("SpawnNet: Leeres iGroup-Template ("+spawngroup+") !");
             Else
               SysLog("SpawnNet: Empty iGroup-Template ("+spawngroup+") !");
             EndIf
             x[rune]:=0;
             Return (0);
           EndIf

           ForEach itemtemplate in itemtemplates // Alle Itemnamen in Zahlen umwandeln
             If (CInt(itemtemplate))
               itemtemplate:=CInt(itemtemplate);
             Else
               itemtemplate:=GetObjtypeByName(itemtemplate);
             EndIf
           EndForEach

           templateb[rune]:=itemtemplates;
         Else
           If (MsgLanguage)
             SysLog("SpawnNet: iGroup-Template ("+templateb[rune]+") existiert nicht!");
           Else
             SysLog("SpawnNet: iGroup-Template ("+templateb[rune]+") doesn't exist!");
           EndIf
           x[rune]:=0;
           Return (0);
         EndIf
       Else
         templateb[rune]:=GetObjtypeByName(templateb[rune]);
       EndIf

       If (flags[rune][2]) // Ist Bit 1 gesetzt? -> InContainerSpawn
         Local cnt:=obj.container; // Den Root-Container suchen
         While ((cnt.container).serial)
           cnt:=cnt.container;
         EndWhile

         If (!cnt)
           If (MsgLanguage)
             SysLog("SpawnNet: Die Rune ("+obj.x+", "+obj.y+") befindet sich in keinem Container!");
           Else
             SysLog("SpawnNet: Rune ("+obj.x+", "+obj.y+") isn't inside a Container!");
           EndIf
           x[rune]:=0;
           Return (0);
         EndIf

         If (aux[rune]<>cnt.serial)
           If (MsgLanguage)
             SysLog("SpawnNet: Die Rune ("+obj.x+", "+obj.y+") befindet sich in einem anderen Container! Gefixt.");
           Else
             SysLog("SpawnNet: Rune ("+obj.x+", "+obj.y+") is inside another Container! Fixed.");
           EndIf

           Local runeobj:=SystemFindObjectBySerial(serial[rune]);
           If (runeobj)
             aux[rune]:=cnt.serial;
             SetObjProperty(runeobj, "aux", cnt.serial);
           Else
             If (MsgLanguage)
               SysLog("SpawnNet: Die Rune ("+x[rune]+", "+y[rune]+") hat sich verfluechtigt!");
             Else
               SysLog("SpawnNet: Rune ("+x[rune]+", "+y[rune]+") is gone away!");
             EndIf
           EndIf
         EndIf
       EndIf

    3: If (CInt(templateb[rune]))
         templateb[rune]:=CInt(templateb[rune]);
       Else
         templateb[rune]:=GetObjtypeByName(templateb[rune]);
       EndIf

    default: If (MsgLanguage)
               SysLog("SpawnNet: Die Rune ("+obj.x+", "+obj.y+") besitzt einen ungueltigen Typ ("+type[rune]+") !");
             Else
               SysLog("SpawnNet: Rune ("+obj.x+", "+obj.y+") has unused Type ("+type[rune]+") !");
             EndIf
             x[rune]:=0;
             Return (0);
  EndCase

  Return (1);
EndFunction

///////////////////////////////////////////////////////
// StartQueue - Fuellt den Zeitpuffer mit allen Runen
///////////////////////////////////////////////////////

Function StartQueue();
  Local spawnrunes; // Alle zu spawnenden Runen zu einem Zeitpunkt
  Local spawntime;  // Der Zeitpunkt
  Local spawnnet;   // Nummer der Rune
  Local contobj;
  Local normal;

  For (spawnnet:=1; spawnnet<=Len(y); spawnnet:=spawnnet+1)
    If (x[spawnnet]<>0)
      If (!amount[spawnnet])
        amount[spawnnet]:=0;
      EndIf

      normal:=1;
      If (type[spawnnet]=3)
        If (!SystemFindObjectBySerial(aux[spawnnet]))
          If (MsgLanguage)
            SysLog("SpawnNet: Die ContainerSpawnRune ("+x[spawnnet]+", "+y[spawnnet]+") hat ihren Container verloren!");
          Else
            SysLog("SpawnNet: ContainerSpawnRune ("+x[spawnnet]+", "+y[spawnnet]+") has lost the Container!");
          EndIf
          aux[spawnnet]:=0;
          normal:=0;
        EndIf
      EndIf

      If (normal)
        spawntime:=mintime[spawnnet];
      Else
        spawntime:=1;
      EndIf

      spawnrunes:=queue[spawntime];
      If (!spawnrunes)
        spawnrunes:={ };
      EndIf
      spawnrunes.append(spawnnet);
      queue[spawntime]:=spawnrunes;
    EndIf
  EndFor
EndFunction

////////////////////////////////////////////////////////
// GetIntValue - Liefer den Wert zurueck, oder Default
////////////////////////////////////////////////////////

Function GetIntValue(value, defvalue)
  Local result:=CInt(value);
  If (!result)
    result:=defvalue;
  EndIf

  Return (result);
EndFunction
